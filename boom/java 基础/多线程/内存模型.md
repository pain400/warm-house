## 线程安全
### 原子性
互斥访问，同一时刻只能有一个线程进行操作

### 可见性
一个线程对主内存的修改可以及时的被其他线程观察到，共享变量在线程间不可见原因有如下几点：
1. 线程交叉执行
2. 重排序结合线程交叉执行
3. 共享变量更新后的值没有在工作内存与主内存间及时更新

### 有序性
如果两个操作的执行次序无法从 happens-before 推导出来，java 虚拟机就可以随意地对这两个操作进行重排序，可以通过 `volatile`、`synchronized`、`Lock` 保证有序性

#### happens-before 原则
1. 程序次序原则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
2. 锁定规则：一个 unLock 操作先行发生于后面对同一个锁的 lock 操作
3. volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
4. 传递规则：若操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C
5. 线程启动原则：如果线程启动操作先于线程的任意操作执行
6. 线程中断原则：对线程 `interrupt` 方法的调用先行发生于被中断线程的代码检测到中断事件的发生
7. 线程终结规则：如果线程 A 执行线程 B 的 `join` 方法，那么线程 B 的任意操作先于线程 A 从 `join` 方法成功返回之前执行
8. 对象终结规则：一个对象的构造函数于该对象的 `finalizer` 方法执行前完成

## MESI
在 MESI 协议中，每个缓存行有以下 4 种状态

### Modified 状态
数据被修改过，但数据有效，且只存在于本缓存中，与主内存中的数据不一致。该缓存中的数据需要在未来的某个时间点（允许其他 CPU 读取主存相应中的内容之前）写回主存，然后状态变成 E（独享）

### Exclusive 状态
数据有效，与内存中的数据一致，且数据只存在于本缓存中。当有其他 CPU 读取该内存时，变成 S（共享）状态，当 CPU 修改该缓存行的内容时变成 M（被修改）状态。一个处于 E 状态的缓存行必须监听其它缓存读主存中该缓存行的操作，一旦有则变成 S 状态

### Shared 状态
数据有效，与内存中的数据一致，且数据分布在多个缓存中。当有一个 CPU 修改该缓存行时，其他 CPU 是可以被作废的，变成 I（无效的）。一个处于 S 状态的缓存行必须监听其他缓存使该缓存行无效或者独享该缓存行的请求，并将缓存行变成无效

### Invalid 状态
缓存数据是无效的

## 内存操作
1. lock：锁定，作用于主内存变量，把变量标识为一条线程独占状态。若一个变量执行了 lock 操作，将清空工作内存中此变量的值，在执行引擎执行之前需要重新 load 或者 assign
2. unlock：解锁，作用于主内存变量，把一个锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。在一个变量执行 unlock 操作之前，必须将此变量同步回主内存
3. read：读取，作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的 load 动作使用
4. load：载入，作用于工作内存变量，把 read 操作从主内存中得到的变量值放入工作内存的变量副本中
5. use：使用，作用于工作内存变量，把工作内存中的一个变量值传递给执行引擎
6. assign：赋值，作用于工作内存变量，把一个从执行引擎接收到的值赋值给工作内存变量
7. store：存储，作用于工作内存变量，把工作内存中的一个变量的值传送到主内存中，以便随后的 write 操作
8. write：写入，作用于主内存变量，把 store 操作从工作内存中传送来的变量值写入主内存变量中

## 内存操作规则
1. 不允许 read 和 load、store 和 write 操作之一单独出现，以上两个操作必须按顺序执行，但没有保证必须连续执行
2. 不允许一个线程丢弃最近的 assign 操作，即变量在工作内存中改变后必须将变化同步回主内存
3. 不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中
4. 一个新的变量只能从主内存中产生，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，也就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作
5. 一个变量在同一个时刻只允许一条线程对其执行 lock 操作，但 lock 操作可以被同一个条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁
6. 若对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值
7. 若一个变量没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许 unlock 一个被其他线程锁定的变量
8. 对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存（执行 store 和 write 操作）

## `volatile`
`volatile` 通过内存屏障与禁止重排序优化来实现内存可见性
1. 对 `volatile` 变量写操作时，在写操作前插入 `StoreStore` 屏障，在写操作后插入 `StoreLoad` 屏障，将本地内存中的共享变量值刷新到主内存中
2. 对 `volatile` 变量读操作时，在读操作前插入 `LoadLoad` 屏障，在读操作后插入 `LoadStore` 屏障，从主内存中读取共享变量

## 内存屏障
1. 确保指令重排序时不会把后面的指令排到内存屏障之前，也不会把前面的指令排到内存屏障之后
2. 强制将对缓存的修改操作立即写入主存
3. 写操作导致其他 CPU 中对应的缓存行无效

### 类型
### LoadLoad 屏障
Load1; LoadLoad; Load2：在 Load2 读取的数据被访问前，保证 Load1 要读取的数据被读取完毕

### StoreStore 屏障
Store1; StoreStore; Store2：在 Store2 写入执行前，保证 Store1 的写入操作对其它处理器可见

### LoadStore 屏障
Load1; LoadStore; Store2：在 Store2 被写入前，保证 Load1 要读取的数据被读取完毕

### StoreLoad 屏障
Store1; StoreLoad; Load2：在 Load2 读取操作执行前，保证 Store1 的写入对所有处理器可见。StoreLoad 屏障的开销是四种屏障中最大的