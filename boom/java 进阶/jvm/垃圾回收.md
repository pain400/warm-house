## 垃圾回收

### 存活判断
#### 引用计数
每个对象都有一个引用计数属性，新增一个引用时计数加 1，引用释放时计数减 1，计数为 0 时可以回收。此方法无法解决对象相互循环引用的问题

#### 可达性分析
从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时为不可达对象

- GC Roots
    - 虚拟机栈中引用的对象
    - 方法区中类静态属性实体引用的对象
    - 方法区中常量引用的对象
    - 本地方法栈中JNI引用的对象

### 垃圾收集算法

#### 标记 -清除算法（Mark-Sweep）
##### 流程
算法分为标记、清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。该算法是最基础的收集算法，后续的收集算法都是基于这种思路并对其缺点进行改进而得到的
##### 劣势
- 效率问题：标记和清除过程的效率都不高
- 空间问题：标记清除之后产生大量不连续的内存碎片，空间碎片太多可能会导致无法分配空间给较大对象而提前触发另一次垃圾收集动作

#### 复制算法（Copying）
##### 流程
该算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉
##### 优势
每次回收都是对其中的一块内存进行回收，内存分配时不需要考虑内存碎片等复杂情况，只用移动堆顶指针，按顺序分配内存即可
##### 劣势
复制收集算法在对象存活率较高时会执行较多的复制操作，效率将会变低。更关键的是，若不想浪费 50% 的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都 100% 存活的极端情况，所以在老年代一般不能直接选用这种算法

#### 标记-压缩算法（Mark-Compact）
##### 流程
标记过程与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

#### 分代收集算法（Generational Collection）
该算法把 Java 堆分为新生代和老年代，从而根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都有大批对象死去，只有少量存活，则选用复制算法，这样只需要付出少量存活对象的复制成本就可以完成收集。在老年代中，由于对象存活率高、没有额外空间对它进行分配担保，则使用标记-清理或标记-整理算法来进行回收

### 垃圾收集器
#### Serial 收集器
串行收集器是最古老、最稳定以及效率高的收集器，由于只使用一个线程去回收，可能会产生较长的停顿。由于单线程设计比较精简，一直是 Client 模式下 JVM 的默认选项。为了区分年代，通常将老年代实现单独称作 Serial Old，它采用了标记-整理算法，区别于新生代的复制算法

##### 参数控制
-XX:+UseSerialGC：串行收集器

#### ParNew 收集器
属于新生代的 GC 实现，该收集器是 Serial 收集器的多线程版本，采用复制算法。通常配合老年代的 CMS 工作

##### 参数控制
-XX:+UseParNewGC：ParNew 收集器
-XX:ParallelGCThreads：限制线程数量

#### Parallel Scavenge 收集器
该收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整参数以提供最合适的停顿时间或最大的吞吐量，也可以通过参数控制 GC 的时间不大于多少毫秒或者比例。具体算法与 Serial GC 比较类似，特点是新生代与老年代 GC 都是并行进行的。其中 Parallel Scavenge 收集器为新生代收集器，采用复制算法；Parallel Old 收集器为老年代版本，使用多线程和标记-整理算法

##### 参数控制
-XX:+UseParallelGC：Parallel 收集器

#### Parallel Old 收集器
Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和标记-整理算法。该收集器在 JDK 1.6 中开始提供

##### 参数控制
-XX:+UseParallelOldGC：Parallel Old 收集器

#### CMS 收集器（Concurrent Mark Sweep）
该收集器是一种以获取最短回收停顿时间为目标的收集器，对 web 等反应时间敏感的应用非常重要

##### 步骤
CMS 收集器是基于标记-清除算法实现的，整个过程分为如下步骤：
- 初始标记（CMS initial mark）
- 并发标记（CMS concurrent mark）
- 重新标记（CMS remark）
- 并发清除（CMS concurrent sweep）

其中初始标记、重新标记这两个步骤仍然需要暂停服务。初始标记仅标记 GC Roots 能直接关联到的对象，速度很快；并发标记阶段进行 GC Roots Tracing 的过程；重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，总体而言 CMS 收集器的内存回收过程是与用户线程一起并发地执行

##### 参数控制
-XX:+UseConcMarkSweepGC：CMS 收集器
-XX:+UseCMSCompactAtFullCollection：Full GC 后进行一次碎片整理，由于整理过程是独占的，会引起停顿时间变长
-XX:+CMSFullGCsBeforeCompaction：Full GC 达到指定次数后进行一次碎片整理
-XX:ParallelCMSThreads：CMS 线程数量（一般约等于可用 CPU 数量）

优点: 并发收集、低停顿
缺点: 存在着内存碎片化问题，所以难以避免在长时间运行等情况下发生 full GC，导致恶劣的停顿。另外，由于强调了并发，CMS 会占用更多 CPU 资源，并和用户线程争抢，并发阶段会降低吞吐量

#### G1 收集器
兼顾吞吐量与停顿时间的 GC 实现
##### 对比 CMS 收集器
1. G1 收集器采用标记整理算法，不会产生内存空间碎片，因此在分配大对象时不会因找不到连续空间而提前触发下一次 GC
2. G1 除了追求低停顿外，还能建立可预测的停顿时间模型，使用者可以明确指定垃圾收集消耗的时间阈值
3. 使用 G1 收集器时，堆的内存布局与其他收集器有很大差别：堆被划分为多个大小相等的独立区域，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂，它们都是一部分（可以不连续）独立区域的集合

##### 步骤
1. 标记阶段，首先初始标记，该阶段暂停服务，并且会触发一次 Minor GC
2. Root Region Scanning，程序运行过程中会回收 survivor 区（存活到老年代），这一过程必须在 young GC 之前完成
3. Concurrent Marking，在整个堆中进行并发标记，此过程可能被 young GC 中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，则这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象存活比例
4. Remark，用来收集并发标记阶段产生新的垃圾，会有短暂停顿；G1 中采用了比 CMS 更快的初始快照算法
5. Copy/Clean up，多线程清除失活对象，会暂停服务。G1 将回收区域的存活对象拷贝到新区域，清除 Remember Sets，并发清空回收区域并把它返回到空闲区域链表中

JVM一般是把一整块堆切分成2000个小region。然后每个小region从1到32Mb不等
这些region最后又被分别标记为Eden,Survivor和old
Humongous 类型主要是用来存储那些比标准块大50%，甚至更大的那些对象

总结起来,G1的年轻代收集归纳如下:
堆就是一整块内存空间,被分为多个heap区(regions)。
年轻代内存由一组不连续的heap块也就是region组成. 这使得在需要时很容易进行容量调整。
年轻代的垃圾收集采用并行复制算法, 会发生stop the world，在回收时所有的应用程序线程都会被暂停。
存活的对象被拷贝到新的 survivor 块或者老年代

老生代的G1垃圾回收有以下几个关键点：
1、并发标记阶段（Concurrent Marking Phase）
活跃度信息在程序运行的时候就被并行的计算了出来
活跃度(liveness)信息标记出哪些区域块最适合回收，在转移暂停期间最适合回收掉。
没有sweep阶段。但CMS是有这个阶段的。
2、重新标记阶段（Remark Phase）
使用了Snapshot-at-the-Beginning (SATB)算法，这个要比CMS的算法快很多。
完全空的区域块会被直接回收掉。
3、复制/清除阶段（Copying/Cleanup Phase）
年轻代和老年代会被同时回收。
老年代的区域块会不会被选择，取决于它的活跃度

### 常用组合
Serial + Serial Old：都是单线程进行 GC，GC 时暂停所有应用线程
Serial + (CMS + Serial Old)：当 CMS GC 失败时，使用 Serial Old 进行 GC
ParNew + CMS：若指定 -XX:+UseConcMarkSweepGC 选项则新生代默认使用 ParNew GC 策略
ParNew + Serial Old：若新生代使用 ParNew GC 策略则老年代默认使用 Serial Old 策略
Parallel Scavenge + Serial Old：Parallel Scavenge 关注吞吐量，尽可能使 CPU 利用率高，适用于后台持久运行的应用程序，不适用于交互较多的应用程序
Parallel Scavenge + Parallel Old：Parallel Old 是 Serial Old 的并行版本
G1GC + G1GC：-XX:+UnlockExperimentalVMOptions
-XX:+UseG1GC 开启
-XX:MaxGCPauseMillis=50 暂停时间目标
-XX:GCPauseIntervalMillis=200 暂停间隔目标
-XX:+G1YoungGenSize=512m 年轻代大小
-XX:SurvivorRatio=6 幸存区比例
-XX:G1HeapRegionSize 设置 region 大小